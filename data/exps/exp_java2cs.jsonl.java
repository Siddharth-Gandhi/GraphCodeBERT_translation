"public void merge(int[] nums1, int m, int[] nums2, int n) {\n                for (int j = 0, i = m; j < n; j++) {\n                                nums1[i] = nums2[j];\n                                i++;\n                }\n                Arrays.sort(nums1);\n}"
"public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        int[][] dp = new int[n+1][n+1];\n\n        for (int level=n-1; level>=0; level--)\n                for (int i=0; i<=level; i++)\n                        dp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);\n\n        return dp[0][0];\n}"
"public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n        if (n <= 1)\n                return 0;\n        \n        //if k >= n/2, then you can make maximum number of transactions.\n        if (k >=  n/2) {\n                int maxPro = 0;\n                for (int i = 1; i < n; i++) {\n                        if (prices[i] > prices[i-1])\n                                maxPro += prices[i] - prices[i-1];\n                }\n                return maxPro;\n        }\n        \n    int[][] dp = new int[k+1][n];\n    for (int i = 1; i <= k; i++) {\n            int localMax = dp[i-1][0] - prices[0];\n            for (int j = 1; j < n; j++) {\n                    dp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);\n                    localMax = Math.max(localMax, dp[i-1][j] - prices[j]);\n            }\n    }\n    return dp[k][n-1];\n}"
"public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder res = new StringBuilder();\n        // \"+\" or \"-\"\n        res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        \n        // integral part\n        res.append(num / den);\n        num %= den;\n        if (num == 0) {\n            return res.toString();\n        }\n        \n        // fractional part\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        map.put(num, res.length());\n        while (num != 0) {\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n            if (map.containsKey(num)) {\n                int index = map.get(num);\n                res.insert(index, \"(\");\n                res.append(\")\");\n                break;\n            }\n            else {\n                map.put(num, res.length());\n            }\n        }\n        return res.toString();\n    }"
"public int longestConsecutive(int[] num) {\n    int res = 0;\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n    for (int n : num) {\n        if (!map.containsKey(n)) {\n            int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n            int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n            // sum: length of the sequence n is in\n            int sum = left + right + 1;\n            map.put(n, sum);\n            \n            // keep track of the max length \n            res = Math.max(res, sum);\n            \n            // extend the length to the boundary(s)\n            // of the sequence\n            // will do nothing if n has no neighbors\n            map.put(n - left, sum);\n            map.put(n + right, sum);\n        }\n        else {\n            // duplicates\n            continue;\n        }\n    }\n    return res;\n}"
"public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\n        PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) -> (b[1] - a[1]));\n        \n        for (int i = 0; i < Profits.length; i++) {\n            pqCap.add(new int[] {Capital[i], Profits[i]});\n        }\n        \n        for (int i = 0; i < k; i++) {\n            while (!pqCap.isEmpty() && pqCap.peek()[0] <= W) {\n                pqPro.add(pqCap.poll());\n            }\n            \n            if (pqPro.isEmpty()) break;\n            \n            W += pqPro.poll()[1];\n        }\n        \n        return W;\n    }"
"public List<String> generateParenthesis(int n) {\n    \n        \n        HashSet<String> allCombos = new HashSet<>();\n        \n        for(int i=0;i<n;i++){\n            \n            if(allCombos.size()==0){                        //Initial situation\n                allCombos.add(\"()\");\n            }\n            else{\n                HashSet<String> combos = new HashSet<>();\n                for(String combo : allCombos){\n\n                    //Add paranthesis to both sides\n                    combos.add(combo+\"()\");\n                    combos.add(\"()\"+combo);\n\n                    //Add paranthesis inside openings\n                    for(int j=0;j<combo.length()-1;j++){\n                        if(combo.charAt(j)=='(' && combo.charAt(j+1)==')'){             //Opening detected\n                            combos.add(combo.substring(0,j+1)+\"()\"+combo.substring(j+1));\n                            combos.add(combo.substring(0,j+1)+\")(\"+combo.substring(j+1));\n                        }\n                    }\n                }\n\n                allCombos = combos;            \n            }\n\n        }\n        \n        return new ArrayList<String>(allCombos);\n    }"
"public List<String> findWords(char[][] board, String[] words) {\n    List<String> res = new ArrayList<>();\n    TrieNode root = buildTrie(words);\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            dfs (board, i, j, root, res);\n        }\n    }\n    return res;\n}\n\npublic void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n    char c = board[i][j];\n    if (c == '#' || p.next[c - 'a'] == null) return;\n    p = p.next[c - 'a'];\n    if (p.word != null) {   // found one\n        res.add(p.word);\n        p.word = null;     // de-duplicate\n    }\n\n    board[i][j] = '#';\n    if (i > 0) dfs(board, i - 1, j ,p, res); \n    if (j > 0) dfs(board, i, j - 1, p, res);\n    if (i < board.length - 1) dfs(board, i + 1, j, p, res); \n    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \n    board[i][j] = c;\n}\n\npublic TrieNode buildTrie(String[] words) {\n    TrieNode root = new TrieNode();\n    for (String w : words) {\n        TrieNode p = root;\n        for (char c : w.toCharArray()) {\n            int i = c - 'a';\n            if (p.next[i] == null) p.next[i] = new TrieNode();\n            p = p.next[i];\n       }\n       p.word = w;\n    }\n    return root;\n}\n\nclass TrieNode {\n    TrieNode[] next = new TrieNode[26];\n    String word;\n}"
"public int minDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        \n        int[][] cost = new int[m + 1][n + 1];\n        for(int i = 0; i <= m; i++)\n            cost[i][0] = i;\n        for(int i = 1; i <= n; i++)\n            cost[0][i] = i;\n        \n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(word1.charAt(i) == word2.charAt(j))\n                    cost[i + 1][j + 1] = cost[i][j];\n                else {\n                    int a = cost[i][j];\n                    int b = cost[i][j + 1];\n                    int c = cost[i + 1][j];\n                    cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\n                    cost[i + 1][j + 1]++;\n                }\n            }\n        }\n        return cost[m][n];\n    }"
"class WordDictionary {\n    private WordDictionary[] children;\n    boolean isEndOfWord;\n    // Initialize your data structure here. \n    public WordDictionary() {\n        children = new WordDictionary[26];\n        isEndOfWord = false;\n    }\n    \n    // Adds a word into the data structure. \n    public void addWord(String word) {\n        WordDictionary curr = this;\n        for(char c: word.toCharArray()){\n            if(curr.children[c - 'a'] == null)\n                curr.children[c - 'a'] = new WordDictionary();\n            curr = curr.children[c - 'a'];\n        }\n        curr.isEndOfWord = true;\n    }\n    \n    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \n    public boolean search(String word) {\n        WordDictionary curr = this;\n        for(int i = 0; i < word.length(); ++i){\n            char c = word.charAt(i);\n            if(c == '.'){\n                for(WordDictionary ch: curr.children)\n                    if(ch != null && ch.search(word.substring(i+1))) return true;\n                return false;\n            }\n            if(curr.children[c - 'a'] == null) return false;\n            curr = curr.children[c - 'a'];\n        }\n        return curr != null && curr.isEndOfWord;\n    }\n}"
"public int maximalSquare(char[][] a) {\n    if(a.length == 0) return 0;\n    int m = a.length, n = a[0].length, result = 0;\n    int[][] b = new int[m+1][n+1];\n    for (int i = 1 ; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if(a[i-1][j-1] == '1') {\n                b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;\n                result = Math.max(b[i][j], result); // update result\n            }\n        }\n    }\n    return result*result;\n}"
"public class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) \n    {\n        List<List<Integer>> sol = new ArrayList<>();\n        travel(root, sol, 0);\n        return sol;\n    }\n    \n    private void travel(TreeNode curr, List<List<Integer>> sol, int level)\n    {\n        if(curr == null) return;\n        \n        if(sol.size() <= level)\n        {\n            List<Integer> newLevel = new LinkedList<>();\n            sol.add(newLevel);\n        }\n        \n        List<Integer> collection  = sol.get(level);\n        if(level % 2 == 0) collection.add(curr.val);\n        else collection.add(0, curr.val);\n        \n        travel(curr.left, sol, level + 1);\n        travel(curr.right, sol, level + 1);\n    }\n}"
"public List<Double> averageOfLevels(TreeNode root) {\n    List<Double> result = new ArrayList<>();\n    Queue<TreeNode> q = new LinkedList<>();\n    \n    if(root == null) return result;\n    q.add(root);\n    while(!q.isEmpty()) {\n        int n = q.size();\n        double sum = 0.0;\n        for(int i = 0; i < n; i++) {\n            TreeNode node = q.poll();\n            sum += node.val;\n            if(node.left != null) q.offer(node.left);\n            if(node.right != null) q.offer(node.right);\n        }\n        result.add(sum / n);\n    }\n    return result;\n}"
"public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n        if (root == null) return true;\n        if (root.val >= maxVal || root.val <= minVal) return false;\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n    }\n}"
"public int[] findOrder(int numCourses, int[][] prerequisites) { \n    if (numCourses == 0) return null;\n    // Convert graph presentation from edges to indegree of adjacent list.\n    int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\n    for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\n        indegree[prerequisites[i][0]]++;    \n\n    Queue<Integer> queue = new LinkedList<Integer>();\n    for (int i = 0; i < numCourses; i++) \n        if (indegree[i] == 0) {\n            // Add the course to the order because it has no prerequisites.\n            order[index++] = i;\n            queue.offer(i);\n        }\n\n    // How many courses don't need prerequisites. \n    while (!queue.isEmpty()) {\n        int prerequisite = queue.poll(); // Already finished this prerequisite course.\n        for (int i = 0; i < prerequisites.length; i++)  {\n            if (prerequisites[i][1] == prerequisite) {\n                indegree[prerequisites[i][0]]--; \n                if (indegree[prerequisites[i][0]] == 0) {\n                    // If indegree is zero, then add the course to the order.\n                    order[index++] = prerequisites[i][0];\n                    queue.offer(prerequisites[i][0]);\n                }\n            } \n        }\n    }\n\n    return (index == numCourses) ? order : new int[0];\n}"
"public class Solution {\n    \n    int minDiff = Integer.MAX_VALUE;\n    TreeNode prev;\n    \n    public int getMinimumDifference(TreeNode root) {\n        inorder(root);\n        return minDiff;\n    }\n    \n    public void inorder(TreeNode root) {\n        if (root == null) return;\n        inorder(root.left);\n        if (prev != null) minDiff = Math.min(minDiff, root.val - prev.val);\n        prev = root;\n        inorder(root.right);\n    }\n\n}"
"class Solution {\n    public HashMap<Integer, Node> map = new HashMap<>();\n    \n    public Node cloneGraph(Node node) {\n        return clone(node);\n    }\n    \n    public Node clone(Node node) {\n        if (node == null) return null;\n        \n        if (map.containsKey(node.val)) \n            return map.get(node.val);\n        \n        Node newNode = new Node(node.val, new ArrayList<Node>());\n        map.put(newNode.val, newNode);\n        for (Node neighbor : node.neighbors) \n            newNode.neighbors.add(clone(neighbor));\n        return newNode;\n    }\n}"
"public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int H = grid.length;\n        int W = grid[0].length;\n        int answer = 0;\n        boolean[][] vis = new boolean[H][W];\n        int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n        for (int row = 0; row < H; ++row) {\n            for (int col = 0; col < W; ++col) {\n                if (!vis[row][col] && grid[row][col] == '1') {\n                    answer++;\n                    Queue<int[]> q = new LinkedList<>();\n                    q.add(new int[]{row, col});\n                    vis[row][col] = true;\n\n                    while (!q.isEmpty()) {\n                        int[] p = q.poll();\n                        for (int[] dir : directions) {\n                            int new_row = p[0] + dir[0];\n                            int new_col = p[1] + dir[1];\n\n                            if (new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !vis[new_row][new_col] && grid[new_row][new_col] == '1') {\n                                q.add(new int[]{new_row, new_col});\n                                vis[new_row][new_col] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return answer;\n    }"
"public int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n        boolean[] visited = new boolean[n * n + 1];\n        for (int move = 0; !queue.isEmpty(); move++) {\n            for (int size = queue.size(); size > 0; size--) {\n                int num = queue.poll();\n                if (visited[num]) continue;\n                visited[num] = true;\n                if (num == n * n) return move;\n                for (int i = 1; i <= 6 && num + i <= n * n; i++) {\n                    int next = num + i;\n                    int value = getBoardValue(board, next);\n                    if (value > 0) next = value;\n                    if (!visited[next]) queue.offer(next);\n                }\n            }\n        }\n        return -1;\n    }\n\n    private int getBoardValue(int[][] board, int num) {\n        int n = board.length;\n        int r = (num - 1) / n;\n        int x = n - 1 - r;\n        int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;\n        return board[x][y];\n    }"
"public int minMutation(String start, String end, String[] bank) {\n        if(start.equals(end)) return 0;\n        \n        Set<String> bankSet = new HashSet<>();\n        for(String b: bank) bankSet.add(b);\n        \n        char[] charSet = new char[]{'A', 'C', 'G', 'T'};\n        \n        int level = 0;\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(start);\n        visited.add(start);\n        \n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            while(size-- > 0) {\n                String curr = queue.poll();\n                if(curr.equals(end)) return level;\n                \n                char[] currArray = curr.toCharArray();\n                for(int i = 0; i < currArray.length; i++) {\n                    char old = currArray[i];\n                    for(char c: charSet) {\n                        currArray[i] = c;\n                        String next = new String(currArray);\n                        if(!visited.contains(next) && bankSet.contains(next)) {\n                            visited.add(next);\n                            queue.offer(next);\n                        }\n                    }\n                    currArray[i] = old;\n                }\n            }\n            level++;\n        }\n        return -1;\n    }"
"public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) {\n            return 0;\n        }\n        Set<String> dict = new HashSet<>(wordList);\n        Set<String> beginSet = new HashSet<>();\n        Set<String> endSet = new HashSet<>();\n        beginSet.add(beginWord);\n        endSet.add(endWord);\n\n        int step = 1;\n        Set<String> visited = new HashSet<>();\n        while (!beginSet.isEmpty() && !endSet.isEmpty()) {\n            if (beginSet.size() > endSet.size()) {\n                Set<String> set = beginSet;\n                beginSet = endSet;\n                endSet = set;\n            }\n            Set<String> temp = new HashSet<>();\n            for (String word : beginSet) {\n                char[] chs = word.toCharArray();\n                for (int i = 0; i < chs.length; i++) {\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        char old = chs[i];\n                        chs[i] = c;\n                        String target = String.valueOf(chs);\n                        if (endSet.contains(target)) {\n                            return step + 1;\n                        }\n                        if (!visited.contains(target) && dict.contains(target)) {\n                            temp.add(target);\n                            visited.add(target);\n                        }\n                        chs[i] = old;\n                    }\n                }\n            }\n            beginSet = temp;\n            step++;\n        }\n        return 0;\n    }"
"public int calculate(String s) {\n    Stack<Integer> stack = new Stack<Integer>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n    for(int i = 0; i < s.length(); i++){\n        char c = s.charAt(i);\n        if(Character.isDigit(c)){\n            number = 10 * number + (int)(c - '0');\n        }else if(c == '+'){\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        }else if(c == '-'){\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        }else if(c == '('){\n            //we push the result first, then sign;\n            stack.push(result);\n            stack.push(sign);\n            //reset the sign and result for the value in the parenthesis\n            sign = 1;   \n            result = 0;\n        }else if(c == ')'){\n            result += sign * number;  \n            number = 0;\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\n            \n        }\n    }\n    if(number != 0) result += sign * number;\n    return result;\n}"
"public boolean isAnagram(String s, String t) {\n        int[] alphabet = new int[26];\n        for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++;\n        for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--;\n        for (int i : alphabet) if (i != 0) return false;\n        return true;\n    }"
"public List<String> summaryRanges(int[] nums) {\n       ArrayList<String> al=new ArrayList<>();\n        \n        for(int i=0;i<nums.length;i++){\n            int start=nums[i];\n            while(i+1<nums.length && nums[i]+1==nums[i+1])\n                i++;\n            \n            if(start!=nums[i]){\n                al.add(\"\"+start+\"->\"+nums[i]);\n            }\n            else{\n                al.add(\"\"+start);\n            }\n        }\n        return al;\n    }"
"public boolean isValid(String s) {\n\tStack<Character> stack = new Stack<Character>();\n\tfor (char c : s.toCharArray()) {\n\t\tif (c == '(')\n\t\t\tstack.push(')');\n\t\telse if (c == '{')\n\t\t\tstack.push('}');\n\t\telse if (c == '[')\n\t\t\tstack.push(']');\n\t\telse if (stack.isEmpty() || stack.pop() != c)\n\t\t\treturn false;\n\t}\n\treturn stack.isEmpty();\n}"
"public boolean hasCycle(ListNode head) {\n  ListNode slow = head, fast = head;\n  \n  while (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n    \n    if (slow == fast) \n        return true;\n  }\n  \n  return false;\n}"
"public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode(0);\n        ListNode handler = head;\n        while(l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                handler.next = l1;\n                l1 = l1.next;\n            } else {\n                handler.next = l2;\n                l2 = l2.next;\n            }\n            handler = handler.next;\n        }\n        \n        if (l1 != null) {\n            handler.next = l1;\n        } else if (l2 != null) {\n            handler.next = l2;\n        }\n        \n        return head.next;\n    }"
"import java.util.Hashtable;\n\n\npublic class LRUCache {\n\nclass DLinkedNode {\n  int key;\n  int value;\n  DLinkedNode pre;\n  DLinkedNode post;\n}\n\n/**\n * Always add the new node right after head;\n */\nprivate void addNode(DLinkedNode node) {\n    \n  node.pre = head;\n  node.post = head.post;\n\n  head.post.pre = node;\n  head.post = node;\n}\n\n/**\n * Remove an existing node from the linked list.\n */\nprivate void removeNode(DLinkedNode node){\n  DLinkedNode pre = node.pre;\n  DLinkedNode post = node.post;\n\n  pre.post = post;\n  post.pre = pre;\n}\n\n/**\n * Move certain node in between to the head.\n */\nprivate void moveToHead(DLinkedNode node){\n  this.removeNode(node);\n  this.addNode(node);\n}\n\n// pop the current tail. \nprivate DLinkedNode popTail(){\n  DLinkedNode res = tail.pre;\n  this.removeNode(res);\n  return res;\n}\n\nprivate Hashtable<Integer, DLinkedNode> \n  cache = new Hashtable<Integer, DLinkedNode>();\nprivate int count;\nprivate int capacity;\nprivate DLinkedNode head, tail;\n\npublic LRUCache(int capacity) {\n  this.count = 0;\n  this.capacity = capacity;\n\n  head = new DLinkedNode();\n  head.pre = null;\n\n  tail = new DLinkedNode();\n  tail.post = null;\n\n  head.post = tail;\n  tail.pre = head;\n}\n\npublic int get(int key) {\n\n  DLinkedNode node = cache.get(key);\n  if(node == null){\n    return -1; // should raise exception here.\n  }\n\n  // move the accessed node to the head;\n  this.moveToHead(node);\n\n  return node.value;\n}\n\n\npublic void put(int key, int value) {\n  DLinkedNode node = cache.get(key);\n\n  if(node == null){\n\n    DLinkedNode newNode = new DLinkedNode();\n    newNode.key = key;\n    newNode.value = value;\n\n    this.cache.put(key, newNode);\n    this.addNode(newNode);\n\n    ++count;\n\n    if(count > capacity){\n      // pop the tail\n      DLinkedNode tail = this.popTail();\n      this.cache.remove(tail.key);\n      --count;\n    }\n  }else{\n    // update the value.\n    node.value = value;\n    this.moveToHead(node);\n  }\n}\n\n}"
"class Solution {\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\n        if(root == null)\n            return false;\n        if(root.left == null && root.right == null){\n            sum = sum + root.val;\n            if(sum == targetSum)\n                return true;   \n        }\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\n    }\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        int sum = 0;\n        return rootToLeafPathSum(root, targetSum, sum);\n    }\n}"
"public Iterable<TreeNode> topSort(TreeNode root) {\n    Deque<TreeNode> result = new LinkedList<>();\n    if (root != null) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode curr = stack.pop();\n            result.push(curr);\n            if (curr.right != null) stack.push(curr.right);\n            if (curr.left != null) stack.push(curr.left);\n        }\n    }\n    return result;\n}"
"public int maxPathSum(TreeNode root) {\n    int result = Integer.MIN_VALUE;\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\n    for (TreeNode node : topSort(root)) {\n        // as we process nodes in post-order their children are already cached\n        int left = Math.max(maxRootPath.get(node.left), 0);\n        int right = Math.max(maxRootPath.get(node.right), 0); \n        maxRootPath.put(node, Math.max(left, right) + node.val);\n        result = Math.max(left + right + node.val, result);\n    }\n    return result;\n}"
