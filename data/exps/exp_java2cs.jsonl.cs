"public void Merge(int[] nums1, int m, int[] nums2, int n) {\n        for (int j = 0, i = m; j < n; j++) {\n            nums1[i] = nums2[j];\n            i++;\n        }\n        Array.Sort(nums1);\n    }"
"public int MinimumTotal(IList<IList<int>> triangle) {\n    int n = triangle.Count;\n    int[][] dp = new int[n + 1][];\n    for (int i = 0; i <= n; i++) {\n        dp[i] = new int[n + 1];\n    }\n\n    for (int level = n - 1; level >= 0; level--) {\n        for (int i = 0; i <= level; i++) {\n            dp[level][i] = triangle[level][i] + Math.Min(dp[level + 1][i], dp[level + 1][i + 1]);\n        }\n    }\n\n    return dp[0][0];\n}"
"public int MaxProfit(int k, int[] prices) {\n        int n = prices.Length;\n        if (n <= 1)\n            return 0;\n        \n        // If k is greater than or equal to n/2, you can make the maximum number of transactions.\n        if (k >= n / 2) {\n            int maxPro = 0;\n            for (int i = 1; i < n; i++) {\n                if (prices[i] > prices[i - 1])\n                    maxPro += prices[i] - prices[i - 1];\n            }\n            return maxPro;\n        }\n        \n        int[,] dp = new int[k + 1, n];\n        for (int i = 1; i <= k; i++) {\n            int localMax = dp[i - 1, 0] - prices[0];\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax);\n                localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]);\n            }\n        }\n        return dp[k, n - 1];\n    }"
"public string FractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) {\n        return \"0\";\n    }\n    StringBuilder res = new StringBuilder();\n    // \"+\" or \"-\"\n    res.Append((numerator > 0) ^ (denominator > 0) ? \"-\" : \"\");\n    long num = System.Math.Abs((long)numerator);\n    long den = System.Math.Abs((long)denominator);\n    \n    // integral part\n    res.Append(num / den);\n    num %= den;\n    if (num == 0) {\n        return res.ToString();\n    }\n    \n    // fractional part\n    res.Append(\".\");\n    Dictionary<long, int> map = new Dictionary<long, int>();\n    map.Add(num, res.Length);\n    while (num != 0) {\n        num *= 10;\n        res.Append(num / den);\n        num %= den;\n        if (map.ContainsKey(num)) {\n            int index = map[num];\n            res.Insert(index, \"(\");\n            res.Append(\")\");\n            break;\n        }\n        else {\n            map.Add(num, res.Length);\n        }\n    }\n    return res.ToString();\n}"
"public int LongestConsecutive(int[] num) {\n        int res = 0;\n        Dictionary<int, int> map = new Dictionary<int, int>();\n        foreach (int n in num) {\n            if (!map.ContainsKey(n)) {\n                int left = map.ContainsKey(n - 1) ? map[n - 1] : 0;\n                int right = map.ContainsKey(n + 1) ? map[n + 1] : 0;\n                // sum: length of the sequence n is in\n                int sum = left + right + 1;\n                map[n] = sum;\n                \n                // keep track of the max length \n                res = System.Math.Max(res, sum);\n                \n                // extend the length to the boundary(s)\n                // of the sequence\n                // will do nothing if n has no neighbors\n                map[n - left] = sum;\n                map[n + right] = sum;\n            }\n            // else part is for duplicates, which is skipped in C# as in Java\n        }\n        return res;\n    }"
"public int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        List<(int Capital, int Profit)> projects = new List<(int Capital, int Profit)>();\n        for (int i = 0; i < Profits.Length; i++) {\n            projects.Add((Capital[i], Profits[i]));\n        }\n\n        // Sort by capital in ascending order\n        projects = projects.OrderBy(p => p.Capital).ToList();\n\n        List<(int Capital, int Profit)> availableProjects = new List<(int Capital, int Profit)>();\n        int index = 0;\n\n        for (int i = 0; i < k; i++) {\n            // Move projects that can be afforded to the available projects list\n            while (index < projects.Count && projects[index].Capital <= W) {\n                availableProjects.Add(projects[index]);\n                index++;\n            }\n\n            // If there are no available projects, break\n            if (!availableProjects.Any()) break;\n\n            // Find the project with the maximum profit\n            var maxProfitProject = availableProjects.OrderByDescending(p => p.Profit).First();\n            W += maxProfitProject.Profit;\n\n            // Remove the selected project from available projects\n            availableProjects.Remove(maxProfitProject);\n        }\n\n        return W;\n    }"
"public IList<string> GenerateParenthesis(int n) {\n        HashSet<string> allCombos = new HashSet<string>();\n        \n        for (int i = 0; i < n; i++) {\n            if (allCombos.Count == 0) { // Initial situation\n                allCombos.Add(\"()\");\n            } else {\n                HashSet<string> combos = new HashSet<string>();\n                foreach (string combo in allCombos) {\n                    // Add parenthesis to both sides\n                    combos.Add(combo + \"()\");\n                    combos.Add(\"()\" + combo);\n\n                    // Add parenthesis inside openings\n                    for (int j = 0; j < combo.Length - 1; j++) {\n                        if (combo[j] == '(' && combo[j + 1] == ')') { // Opening detected\n                            combos.Add(combo.Substring(0, j + 1) + \"()\" + combo.Substring(j + 1));\n                            combos.Add(combo.Substring(0, j + 1) + \")(\" + combo.Substring(j + 1));\n                        }\n                    }\n                }\n\n                allCombos = combos;\n            }\n        }\n\n        return new List<string>(allCombos);\n    }"
"public class Solution {\n    public IList<string> FindWords(char[][] board, string[] words) {\n        List<string> res = new List<string>();\n        TrieNode root = BuildTrie(words);\n        for (int i = 0; i < board.Length; i++) {\n            for (int j = 0; j < board[0].Length; j++) {\n                Dfs(board, i, j, root, res);\n            }\n        }\n        return res;\n    }\n\n    public void Dfs(char[][] board, int i, int j, TrieNode p, List<string> res) {\n        char c = board[i][j];\n        if (c == '#' || p.Next[c - 'a'] == null) return;\n        p = p.Next[c - 'a'];\n        if (p.Word != null) { // found one\n            res.Add(p.Word);\n            p.Word = null; // de-duplicate\n        }\n\n        board[i][j] = '#';\n        if (i > 0) Dfs(board, i - 1, j, p, res);\n        if (j > 0) Dfs(board, i, j - 1, p, res);\n        if (i < board.Length - 1) Dfs(board, i + 1, j, p, res);\n        if (j < board[0].Length - 1) Dfs(board, i, j + 1, p, res);\n        board[i][j] = c;\n    }\n\n    public TrieNode BuildTrie(string[] words) {\n        TrieNode root = new TrieNode();\n        foreach (string w in words) {\n            TrieNode p = root;\n            foreach (char c in w) {\n                int i = c - 'a';\n                if (p.Next[i] == null) p.Next[i] = new TrieNode();\n                p = p.Next[i];\n            }\n            p.Word = w;\n        }\n        return root;\n    }\n}\n\npublic class TrieNode {\n    public TrieNode[] Next = new TrieNode[26];\n    public string Word;\n}"
"public int MinDistance(string word1, string word2) {\n        int m = word1.Length;\n        int n = word2.Length;\n\n        int[,] cost = new int[m + 1, n + 1];\n        for (int i = 0; i <= m; i++)\n            cost[i, 0] = i;\n        for (int i = 1; i <= n; i++)\n            cost[0, i] = i;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (word1[i] == word2[j])\n                    cost[i + 1, j + 1] = cost[i, j];\n                else {\n                    int a = cost[i, j];\n                    int b = cost[i, j + 1];\n                    int c = cost[i + 1, j];\n                    cost[i + 1, j + 1] = Math.Min(a, Math.Min(b, c)) + 1;\n                }\n            }\n        }\n        return cost[m, n];\n    }"
"public class WordDictionary {\n    private WordDictionary[] children;\n    private bool isEndOfWord;\n\n    // Initialize your data structure here. \n    public WordDictionary() {\n        children = new WordDictionary[26];\n        isEndOfWord = false;\n    }\n    \n    // Adds a word into the data structure. \n    public void AddWord(string word) {\n        WordDictionary curr = this;\n        foreach (char c in word) {\n            if (curr.children[c - 'a'] == null)\n                curr.children[c - 'a'] = new WordDictionary();\n            curr = curr.children[c - 'a'];\n        }\n        curr.isEndOfWord = true;\n    }\n    \n    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \n    public bool Search(string word) {\n        return Search(word, 0, this);\n    }\n\n    private bool Search(string word, int index, WordDictionary node) {\n        if (node == null) return false;\n        if (index == word.Length) return node.isEndOfWord;\n\n        char c = word[index];\n        if (c == '.') {\n            foreach (WordDictionary child in node.children) {\n                if (child != null && Search(word, index + 1, child)) return true;\n            }\n            return false;\n        } else {\n            return Search(word, index + 1, node.children[c - 'a']);\n        }\n    }\n}"
"public int MaximalSquare(char[][] a) {\n    if (a.Length == 0) return 0;\n    int m = a.Length, n = a[0].Length, result = 0;\n    int[,] b = new int[m + 1, n + 1];\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (a[i - 1][j - 1] == '1') {\n                b[i, j] = Math.Min(Math.Min(b[i, j - 1], b[i - 1, j - 1]), b[i - 1, j]) + 1;\n                result = Math.Max(b[i, j], result); // update result\n            }\n        }\n    }\n    return result * result;\n}"
"public class Solution {\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\n        IList<IList<int>> sol = new List<IList<int>>();\n        Travel(root, sol, 0);\n        return sol;\n    }\n\n    private void Travel(TreeNode curr, IList<IList<int>> sol, int level) {\n        if (curr == null) return;\n\n        if (sol.Count <= level) {\n            IList<int> newLevel = new List<int>();\n            sol.Add(newLevel);\n        }\n\n        IList<int> collection = sol[level];\n        if (level % 2 == 0) collection.Add(curr.val);\n        else collection.Insert(0, curr.val);\n\n        Travel(curr.left, sol, level + 1);\n        Travel(curr.right, sol, level + 1);\n    }\n}"
"public IList<double> AverageOfLevels(TreeNode root) {\n        List<double> result = new List<double>();\n        Queue<TreeNode> q = new Queue<TreeNode>();\n    \n        if (root == null) return result;\n        q.Enqueue(root);\n        while (q.Count > 0) {\n            int n = q.Count;\n            double sum = 0.0;\n            for (int i = 0; i < n; i++) {\n                TreeNode node = q.Dequeue();\n                sum += node.val;\n                if (node.left != null) q.Enqueue(node.left);\n                if (node.right != null) q.Enqueue(node.right);\n            }\n            result.Add(sum / n);\n        }\n        return result;\n    }"
"public class Solution {\n    public bool IsValidBST(TreeNode root) {\n        return IsValidBST(root, long.MinValue, long.MaxValue);\n    }\n    \n    public bool IsValidBST(TreeNode root, long minVal, long maxVal) {\n        if (root == null) return true;\n        if (root.val >= maxVal || root.val <= minVal) return false;\n        return IsValidBST(root.left, minVal, root.val) && IsValidBST(root.right, root.val, maxVal);\n    }\n}"
"public int[] FindOrder(int numCourses, int[][] prerequisites) {\n    if (numCourses == 0) return null;\n    // Convert graph presentation from edges to indegree of adjacent list.\n    int[] indegree = new int[numCourses], order = new int[numCourses];\n    int index = 0;\n    for (int i = 0; i < prerequisites.Length; i++) // Indegree - how many prerequisites are needed.\n        indegree[prerequisites[i][0]]++;\n\n    Queue<int> queue = new Queue<int>();\n    for (int i = 0; i < numCourses; i++)\n        if (indegree[i] == 0) {\n            // Add the course to the order because it has no prerequisites.\n            order[index++] = i;\n            queue.Enqueue(i);\n        }\n\n    // How many courses don't need prerequisites.\n    while (queue.Count > 0) {\n        int prerequisite = queue.Dequeue(); // Already finished this prerequisite course.\n        for (int i = 0; i < prerequisites.Length; i++) {\n            if (prerequisites[i][1] == prerequisite) {\n                indegree[prerequisites[i][0]]--;\n                if (indegree[prerequisites[i][0]] == 0) {\n                    // If indegree is zero, then add the course to the order.\n                    order[index++] = prerequisites[i][0];\n                    queue.Enqueue(prerequisites[i][0]);\n                }\n            }\n        }\n    }\n\n    return (index == numCourses) ? order : new int[0];\n}"
"public class Solution {\n    int minDiff = int.MaxValue;\n    TreeNode prev;\n\n    public int GetMinimumDifference(TreeNode root) {\n        Inorder(root);\n        return minDiff;\n    }\n\n    public void Inorder(TreeNode root) {\n        if (root == null) return;\n        Inorder(root.left);\n        if (prev != null) minDiff = Math.Min(minDiff, root.val - prev.val);\n        prev = root;\n        Inorder(root.right);\n    }\n}"
"public class Solution {\n    private Dictionary<int, Node> map = new Dictionary<int, Node>();\n\n    public Node CloneGraph(Node node) {\n        return Clone(node);\n    }\n\n    private Node Clone(Node node) {\n        if (node == null) return null;\n\n        if (map.ContainsKey(node.val))\n            return map[node.val];\n\n        Node newNode = new Node(node.val, new List<Node>());\n        map.Add(newNode.val, newNode);\n        foreach (Node neighbor in node.neighbors)\n            newNode.neighbors.Add(Clone(neighbor));\n        return newNode;\n    }\n}"
"public int NumIslands(char[][] grid) {\n    if (grid == null || grid.Length == 0 || grid[0].Length == 0) {\n        return 0;\n    }\n    int H = grid.Length;\n    int W = grid[0].Length;\n    int answer = 0;\n    bool[,] vis = new bool[H, W];\n    int[][] directions = new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 }, new int[] { -1, 0 }, new int[] { 0, -1 } };\n\n    for (int row = 0; row < H; ++row) {\n        for (int col = 0; col < W; ++col) {\n            if (!vis[row, col] && grid[row][col] == '1') {\n                answer++;\n                Queue<int[]> q = new Queue<int[]>();\n                q.Enqueue(new int[] { row, col });\n                vis[row, col] = true;\n\n                while (q.Count > 0) {\n                    int[] p = q.Dequeue();\n                    foreach (int[] dir in directions) {\n                        int newRow = p[0] + dir[0];\n                        int newCol = p[1] + dir[1];\n\n                        if (newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !vis[newRow, newCol] && grid[newRow][newCol] == '1') {\n                            q.Enqueue(new int[] { newRow, newCol });\n                            vis[newRow, newCol] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return answer;\n}"
"public int SnakesAndLadders(int[][] board) {\n    int n = board.Length;\n    Queue<int> queue = new Queue<int>();\n    queue.Enqueue(1);\n    bool[] visited = new bool[n * n + 1];\n    for (int move = 0; !queue.Count.Equals(0); move++) {\n        for (int size = queue.Count; size > 0; size--) {\n            int num = queue.Dequeue();\n            if (visited[num]) continue;\n            visited[num] = true;\n            if (num == n * n) return move;\n            for (int i = 1; i <= 6 && num + i <= n * n; i++) {\n                int next = num + i;\n                int value = GetBoardValue(board, next);\n                if (value > 0) next = value;\n                if (!visited[next]) queue.Enqueue(next);\n            }\n        }\n    }\n    return -1;\n}\n\nprivate int GetBoardValue(int[][] board, int num) {\n    int n = board.Length;\n    int r = (num - 1) / n;\n    int x = n - 1 - r;\n    int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;\n    return board[x][y];\n}"
"public int MinMutation(string start, string end, string[] bank) {\n    if (start.Equals(end)) return 0;\n\n    HashSet<string> bankSet = new HashSet<string>(bank);\n\n    char[] charSet = new char[] { 'A', 'C', 'G', 'T' };\n\n    int level = 0;\n    HashSet<string> visited = new HashSet<string>();\n    Queue<string> queue = new Queue<string>();\n    queue.Enqueue(start);\n    visited.Add(start);\n\n    while (queue.Count > 0) {\n        int size = queue.Count;\n        while (size-- > 0) {\n            string curr = queue.Dequeue();\n            if (curr.Equals(end)) return level;\n\n            char[] currArray = curr.ToCharArray();\n            for (int i = 0; i < currArray.Length; i++) {\n                char old = currArray[i];\n                foreach (char c in charSet) {\n                    currArray[i] = c;\n                    string next = new string(currArray);\n                    if (!visited.Contains(next) && bankSet.Contains(next)) {\n                        visited.Add(next);\n                        queue.Enqueue(next);\n                    }\n                }\n                currArray[i] = old;\n            }\n        }\n        level++;\n    }\n    return -1;\n}"
"public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n    if (!wordList.Contains(endWord)) {\n        return 0;\n    }\n    HashSet<string> dict = new HashSet<string>(wordList);\n    HashSet<string> beginSet = new HashSet<string>(), endSet = new HashSet<string>();\n    beginSet.Add(beginWord);\n    endSet.Add(endWord);\n\n    int step = 1;\n    HashSet<string> visited = new HashSet<string>();\n    while (beginSet.Count > 0 && endSet.Count > 0) {\n        if (beginSet.Count > endSet.Count) {\n            var set = beginSet;\n            beginSet = endSet;\n            endSet = set;\n        }\n        HashSet<string> temp = new HashSet<string>();\n        foreach (string word in beginSet) {\n            char[] chs = word.ToCharArray();\n            for (int i = 0; i < chs.Length; i++) {\n                for (char c = 'a'; c <= 'z'; c++) {\n                    char old = chs[i];\n                    chs[i] = c;\n                    string target = new string(chs);\n                    if (endSet.Contains(target)) {\n                        return step + 1;\n                    }\n                    if (!visited.Contains(target) && dict.Contains(target)) {\n                        temp.Add(target);\n                        visited.Add(target);\n                    }\n                    chs[i] = old;\n                }\n            }\n        }\n        beginSet = temp;\n        step++;\n    }\n    return 0;\n}"
"public int Calculate(string s) {\n    Stack<int> stack = new Stack<int>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n    for (int i = 0; i < s.Length; i++) {\n        char c = s[i];\n        if (char.IsDigit(c)) {\n            number = 10 * number + (c - '0');\n        } else if (c == '+') {\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        } else if (c == '(') {\n            // we push the result first, then sign;\n            stack.Push(result);\n            stack.Push(sign);\n            // reset the sign and result for the value in the parenthesis\n            sign = 1;   \n            result = 0;\n        } else if (c == ')') {\n            result += sign * number;  \n            number = 0;\n            result *= stack.Pop();    // stack.Pop() is the sign before the parenthesis\n            result += stack.Pop();   // stack.Pop() now is the result calculated before the parenthesis\n            \n        }\n    }\n    if (number != 0) result += sign * number;\n    return result;\n}"
"public bool IsAnagram(string s, string t) {\n    int[] alphabet = new int[26];\n    for (int i = 0; i < s.Length; i++) alphabet[s[i] - 'a']++;\n    for (int i = 0; i < t.Length; i++) alphabet[t[i] - 'a']--;\n    foreach (int i in alphabet) if (i != 0) return false;\n    return true;\n}"
"public List<string> SummaryRanges(int[] nums) {\n    List<string> ranges = new List<string>();\n    \n    for (int i = 0; i < nums.Length; i++) {\n        int start = nums[i];\n        while (i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]) {\n            i++;\n        }\n\n        if (start != nums[i]) {\n            ranges.Add(start + \"->\" + nums[i]);\n        } else {\n            ranges.Add(start.ToString());\n        }\n    }\n    return ranges;\n}"
"public bool IsValid(string s) {\n    Stack<char> stack = new Stack<char>();\n    foreach (char c in s) {\n        if (c == '(')\n            stack.Push(')');\n        else if (c == '{')\n            stack.Push('}');\n        else if (c == '[')\n            stack.Push(']');\n        else if (stack.Count == 0 || stack.Pop() != c)\n            return false;\n    }\n    return stack.Count == 0;\n}"
"public bool HasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) \n            return true;\n    }\n\n    return false;\n}"
"public ListNode MergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode head = new ListNode(0);\n    ListNode handler = head;\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            handler.next = l1;\n            l1 = l1.next;\n        } else {\n            handler.next = l2;\n            l2 = l2.next;\n        }\n        handler = handler.next;\n    }\n\n    if (l1 != null) {\n        handler.next = l1;\n    } else if (l2 != null) {\n        handler.next = l2;\n    }\n\n    return head.next;\n}"
"public class LRUCache {\n\n    class DLinkedNode {\n        public int key;\n        public int value;\n        public DLinkedNode prev;\n        public DLinkedNode next;\n    }\n\n    private void AddNode(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void RemoveNode(DLinkedNode node) {\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n\n        prev.next = next;\n        next.prev = prev;\n    }\n\n    private void MoveToHead(DLinkedNode node) {\n        RemoveNode(node);\n        AddNode(node);\n    }\n\n    private DLinkedNode PopTail() {\n        DLinkedNode res = tail.prev;\n        RemoveNode(res);\n        return res;\n    }\n\n    private Dictionary<int, DLinkedNode> cache = new Dictionary<int, DLinkedNode>();\n    private int count;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.count = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        head.prev = null;\n\n        tail = new DLinkedNode();\n        tail.next = null;\n\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int Get(int key) {\n        if (!cache.ContainsKey(key)) {\n            return -1;\n        }\n\n        DLinkedNode node = cache[key];\n        MoveToHead(node);\n\n        return node.value;\n    }\n\n    public void Put(int key, int value) {\n        if (!cache.ContainsKey(key)) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.value = value;\n\n            cache[key] = newNode;\n            AddNode(newNode);\n\n            ++count;\n\n            if (count > capacity) {\n                DLinkedNode tail = PopTail();\n                cache.Remove(tail.key);\n                --count;\n            }\n        } else {\n            DLinkedNode node = cache[key];\n            node.value = value;\n            MoveToHead(node);\n        }\n    }\n}"
"public class Solution {\n    public bool RootToLeafPathSum(TreeNode root, int targetSum, int sum) {\n        if (root == null)\n            return false;\n        if (root.left == null && root.right == null) {\n            sum += root.val;\n            if (sum == targetSum)\n                return true;\n        }\n        return RootToLeafPathSum(root.left, targetSum, sum + root.val) || RootToLeafPathSum(root.right, targetSum, sum + root.val);\n    }\n\n    public bool HasPathSum(TreeNode root, int targetSum) {\n        int sum = 0;\n        return RootToLeafPathSum(root, targetSum, sum);\n    }\n}"
"public IEnumerable<TreeNode> TopSort(TreeNode root) {\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\n    if (root != null) {\n        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n        stack.AddFirst(root);\n        while (stack.Count > 0) {\n            TreeNode curr = stack.First.Value;\n            stack.RemoveFirst();\n            result.AddFirst(curr);\n            if (curr.right != null) stack.AddFirst(curr.right);\n            if (curr.left != null) stack.AddFirst(curr.left);\n        }\n    }\n    return result;\n}"
"public int MaxPathSum(TreeNode root) {\n    int result = int.MinValue;\n    Dictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode, int>(); // cache\n    maxRootPath[null] = 0; // for simplicity we want to handle null nodes\n    foreach (TreeNode node in TopSort(root)) {\n        // as we process nodes in post-order their children are already cached\n        int left = Math.Max(maxRootPath.GetValueOrDefault(node.left, 0), 0);\n        int right = Math.Max(maxRootPath.GetValueOrDefault(node.right, 0), 0); \n        maxRootPath[node] = Math.Max(left, right) + node.val;\n        result = Math.Max(left + right + node.val, result);\n    }\n    return result;\n}"
