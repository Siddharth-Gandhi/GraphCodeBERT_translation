public class Solution { public void Merge(int[] nums1, int m, int[] nums2, int n) { for (int j = 0, i = m; j < n; j++) { nums1[i] = nums2[j]; i++; } Array.Sort(nums1); } }
class Solution { private int?[][] memo; public int MinimumTotal(IList<IList<int>> triangle) { int n = triangle.Count; memo = new int?[n][]; for (int i = 0; i < n; i++) { memo[i] = new int?[n]; } return Dfs(0, 0, triangle); } private int Dfs(int level, int i, IList<IList<int>> triangle) { if (memo[level][i].HasValue) return memo[level][i].Value; int path = triangle[level][i]; if (level < triangle.Count - 1) path += Math.Min(Dfs(level + 1, i, triangle), Dfs(level + 1, i + 1, triangle)); return (int)(memo[level][i] = path); } }
class Solution { public int MaxProfit(int k, int[] prices) { int n = prices.Length; if (n <= 1) return 0; if (k >= n / 2) { int maxPro = 0; for (int i = 1; i < n; i++) { if (prices[i] > prices[i - 1]) maxPro += prices[i] - prices[i - 1]; } return maxPro; } int[,] dp = new int[k + 1, n]; for (int i = 1; i <= k; i++) { int localMax = dp[i - 1, 0] - prices[0]; for (int j = 1; j < n; j++) { dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax); localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]); } } return dp[k, n - 1]; } }
